-- Chapter 18

import qualified Data.Map as Map
import Data.List (sort, group, intercalate)
import Data.Maybe

data Organ = Heart | Brain | Kidney | Liver | Lung | Spleen deriving (Show, Eq, Ord, Enum)

organs :: [Organ]
organs = [Heart, Heart, Brain, Spleen, Spleen, Kidney, Kidney, Kidney]

ids :: [Int]
ids = [2, 7, 13, 14, 18, 21, 34, 55]

organPairs :: [(Int, Organ)]
organPairs = zip ids organs

organCatalog :: Map.Map Int Organ
organCatalog = Map.fromList organPairs

-- Given an organ catalogue, create an inventory of how many of each type of organ there is. If an organ
-- is not in the catalogue, it isn't represented in the inventory.
-- If you query the inventory with Map.lookup with an organ not in the inventory, it will return Nothing.
-- You can use "Map.findWithDefault 0 <organ> organInventory"to return 0 for organs not in inventory.
organInventory :: Map.Map Organ Int
organInventory = 
    Map.fromList . map (\x -> (head x, length x)) . group . sort . snd . unzip $ Map.toAscList organCatalog


-- Inventory from Chapter 19
-- Instead of the exercise in Chapter 18, in Chapter 19 we create an inventory as a list generated by
-- searching through all opssible drawers

possibleDrawers :: [Int]
possibleDrawers = [1..50]

getDrawerContents :: [Int] -> Map.Map Int Organ -> [Maybe Organ]
getDrawerContents ids catalog = map getContents ids
    where
        getContents = \id -> Map.lookup id catalog

availableOrgans :: [Maybe Organ]
availableOrgans = getDrawerContents possibleDrawers organCatalog

countOrgan :: Organ -> [Maybe Organ] -> Int
countOrgan organ available = length (filter
                                        (\x -> x == Just organ)
                                        available)

-- Use list comprehension to create a complete inventory
organCounts = [(organ, countOrgan organ availableOrgans) | organ <- [Heart .. Spleen]]

-- Display the available organs

justTheOrgans = filter isJust availableOrgans

showOrgan :: Maybe Organ -> String
showOrgan (Just organ) = show organ
showOrgan Nothing = " "

-- Use as: listOrgans justTheOrgans
listOrgans :: [Maybe Organ] -> String
listOrgans = intercalate ", " . map showOrgan

-- Back to the Lab!

data Container = Vat Organ | Cooler Organ | Bag Organ

instance Show Container where
    show (Vat organ) = show organ ++ " in a vat"
    show (Cooler organ) = show organ ++ " in a cooler"
    show (Bag organ) = show organ ++ " in a bag"

data Location = Lab | Kitchen | Bathroom deriving Show

organToContainer :: Organ -> Container
organToContainer Brain = Vat Brain
organToContainer Heart = Cooler Heart
organToContainer organ = Bag organ

placeInLocation :: Container -> (Location, Container)
placeInLocation (Vat a) = (Lab, Vat a)
placeInLocation (Cooler a) = (Lab, Cooler a)
placeInLocation (Bag a) = (Kitchen, Bag a)

process :: Organ -> (Location, Container)
process organ = placeInLocation (organToContainer organ)

report :: (Location, Container) -> String
report (location, container) = show container ++ " in the " ++ show location

processAndReport :: (Maybe Organ) -> String
processAndReport (Just organ) = report (process organ)
processAndReport Nothing = "error, id not found"

processRequest :: Int -> Map.Map Int Organ -> String
processRequest id catalog = processAndReport organ
    where organ = Map.lookup id catalog

emptyDrawers :: [Maybe Organ] -> Int
emptyDrawers = length . filter isNothing

maybeMap :: (a -> b) -> Maybe a -> Maybe b
maybeMap f Nothing = Nothing
maybeMap f (Just val) = Just (f val)
